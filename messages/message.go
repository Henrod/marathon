package messages

// KafkaMessage is the message to be sent to Kafka
type KafkaMessage struct {
	Message string
	Topic   string
}

// InputMessage read by the parser
// If Template has a value it should be fetched and placed into Message,
// and Params should be merged with Defaults from the template.
type InputMessage struct {
	App        string                 `json:"app"`
	Token      string                 `json:"token"`
	Service    string                 `json:"service"`
	PushExpiry int64                  `json:"push_expiry"`
	Locale     string                 `json:"locale,omitempty"`
	Template   string                 `json:"template,omitempty"`
	Params     map[string]interface{} `json:"params,omitempty"`
	Message    map[string]interface{} `json:"message,omitempty"`
	Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// NewInputMessage Build an empty InputMessage
func NewInputMessage() *InputMessage {
	msg := new(InputMessage)
	msg.Params = make(map[string]interface{})
	msg.Message = make(map[string]interface{})
	msg.Metadata = make(map[string]interface{})
	return msg
}

// TemplatedMessage generated by the parser and which should reach the MessageBuilder.
// Message should have the message in templated format '%{', '}'
// Params should be the merge of template Defaults and input params
type TemplatedMessage struct {
	App        string                 `json:"app"`
	Token      string                 `json:"token"`
	Service    string                 `json:"service"`
	PushExpiry int64                  `json:"push_expiry"`
	Locale     string                 `json:"locale,omitempty"`
	Params     map[string]interface{} `json:"params,omitempty"`
	Message    map[string]interface{} `json:"message,omitempty"`
	Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// NewTemplatedMessage Build an empty ApnsMessage
func NewTemplatedMessage() *TemplatedMessage {
	msg := new(TemplatedMessage)
	msg.Params = make(map[string]interface{})
	msg.Message = make(map[string]interface{})
	msg.Metadata = make(map[string]interface{})
	return msg
}

// ApnsMessage might need to update the json encoding if we change to snake case
type ApnsMessage struct {
	DeviceToken string             `json:"DeviceToken"`
	Payload     ApnsPayloadContent `json:"Payload"`
	PushExpiry  int64              `json:"push_expiry"`
}

// ApnsPayloadContent stores payload content of apns message
type ApnsPayloadContent struct {
	Aps map[string]interface{} `json:"aps"`
	M   map[string]interface{} `json:"m,omitempty"`
}

// NewApnsMessage Build an empty ApnsMessage
func NewApnsMessage() *ApnsMessage {
	msg := new(ApnsMessage)
	msg.Payload = ApnsPayloadContent{}
	return msg
}

// GcmMessage is the struct to store a gcm message
type GcmMessage struct {
	To         string                 `json:"to"`
	Data       map[string]interface{} `json:"data"`
	PushExpiry int64                  `json:"push_expiry"`
}

// NewGcmMessage Build an empty GcmMessage
func NewGcmMessage() *GcmMessage {
	msg := new(GcmMessage)
	msg.Data = make(map[string]interface{})
	return msg
}
